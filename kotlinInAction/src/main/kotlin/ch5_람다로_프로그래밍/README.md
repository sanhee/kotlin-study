


## 컬렉션 함수형 API

### filter, map

> 공통점: list를 반환한다.

- filter : 입력 컬렉션의 원소 중에서 주어진 predicate를 만족하는 원소만으로 이뤄진 새로운 컬렉션
  - filter는 원소를 변환할 수는 없다.
  - 변환하려면 map을 사용해야한다.
- map : 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.

### 큰 컬렉션에 대해서 비효율적인 컬렉션 연산

```kotlin
people.map(Person::name).filter {it.startsWith("A")}
```
- 연쇄 호출이 중간 리스트를 2개 만든다.
- 리스트 요소가 많아지게 되면 효율이 떨어진다.

### 지연 계산(lazy) 컬렉션 연산

- map이나 filter 같은 컬렉션 함수들은 결과 컬렉션을 `즉시` 생성한다.
  - 이는 컬렉션 함수를 연쇄하면 `매 단계`마다 계산 `중간 결과`를 새로운 컬렉션에 임시로 담는다는 말이다.
- 시퀀스를 사용하면 `중간 임시 컬렉션`을 **사용하지 않고도** 컬렉션 연산을 연쇄할 수 있다.
- 각 연산이 컬렉션을 직접 사용하는 대신 `시퀀스`를 사용하게 만들어야 한다.
- 

```kotlin
people.asSequence()
  .map(Person::name)
  .filter{ it.startsWith("A")}
  .toList()

// 위 예제와 결과는 같다.
// 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 `원소가 많은 경우` 성능이 눈에 띄게 좋아진다.
```

### 자바 stream과 코틀린 sequence

- Java 8 Stream과 Sequence는 Lazy evaluation 동작 개념이 동일하다.
- 코틀린에서 같은 개념을 따로 구현해 제공하는 이유는 안드로이드 등에서 예전 버전 자바를 사용하는 경우 자바 8에 있는 `stream`이 없기 때문이다.
- 자바 8을 채택하면, 코틀린 컬렉션과 시퀀스에서 제공하지 않는 중요한 기능을 사용할 수 있다.
  - stream 연산을 여러 CPU에서 병렬적으로 실행하는 기능


### Kotlin - Collections와 Sequences의 차이점
- https://codechacha.com/ko/kotlin-sequences/


# 5장 요약

- 람다를 사용하면 코드 조각을 다른 함수에게 인자를 넘길 수 있다.
- 코틀린에서는 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고,
  - 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 `it`이라는 디폴트 이름으로 부를 수 있다.
- 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다. (자바와 다른 부분)
- 메소드, 생성자, 프로퍼티의 이름 앞에 `::`을 붙이면 각각에 대한 참조를 만들 수 있다.
  - 그런 참조를 람다 대신 다른 함수에게 넘길 수 있다.
- filter, map, all, any 등의 함수를 활용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다.
- 시퀀스를 사용하면 중간 결과를 담는 컬렉션을 생성하지 않고도 컬렉션에 대한 여러 연산을 조합할 수 있다.
- 함수형 인터페이스(추상 메소드가 단 하나뿐인 인터페이스)를 인자로 받는 자바 함수를 호출할 경우 람다를 함수형 인터페이스 인자 대신 넘길 수 있다.
- 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다.
- 표준 라이브러리의 `with`함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출 할 수 있다.
  - `apply`를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다.